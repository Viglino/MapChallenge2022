function e(e){return e&&e.__esModule?e.default:e}var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},i={},n={},r=t.parcelRequirecc54;null==r&&((r=function(e){if(e in i)return i[e].exports;if(e in n){var t=n[e];delete n[e];var r={id:e,exports:{}};return i[e]=r,t.call(r.exports,r,r.exports),r.exports}var s=new Error("Cannot find module '"+e+"'");throw s.code="MODULE_NOT_FOUND",s}).register=function(e,t){n[e]=t},t.parcelRequirecc54=r);var s=r("7qsnY"),o=r("20LS2"),a=r("6gELa"),d=r("kPMpK"),l=r("3hQzq"),h=r("610XN"),u=r("l9IGS"),g=r("2zf1Y"),c=r("5Revz"),f=r("31ZqB"),_=r("eHnTw"),m=r("iTTi2"),p=r("cw4dl"),y=r("iGyOD"),x=r("7h13W"),v=r("j2K3b"),C=r("pMeEw"),S=r("9iujS"),w=r("gKdkP"),E=(h=r("610XN"),o=r("20LS2"),r("btuox")),F=r("jZquI"),P=r("d1ltq"),M=(u=r("l9IGS"),r("kBSVF")),b=r("cgPpQ"),T=r("gzr8q"),G=r("lVQul");const U=[0,0,0,0],B=[],L="modifystart",V="modifyend";class A extends m.default{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class D extends C.default{constructor(e){let t;if(super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:E.primaryAction,this.defaultDeleteCondition_=function(e){return(0,E.altKeyOnly)(e)&&(0,E.singleClick)(e)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:E.always,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new(0,S.default),this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new(0,h.default)({source:new(0,o.default)({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:N(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null,e.features?t=e.features:e.source&&(this.source_=e.source,t=new(0,f.default)(this.source_.getFeatures()),this.source_.addEventListener(w.default.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(w.default.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(_.default.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(_.default.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=void 0===e.snapToPointer?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),e.addEventListener(p.default.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new(0,f.default);const i=this.featuresBeingModified_.getArray();for(let e=0,n=t.length;e<n;++e){const n=t[e];for(let e=0,t=n.length;e<t;++e){const t=n[e].feature;t&&!i.includes(t)&&this.featuresBeingModified_.push(t)}}0===this.featuresBeingModified_.getLength()?this.featuresBeingModified_=null:this.dispatchEvent(new A(L,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(p.default.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach((function(t){e===t.feature&&i.push(t)}));for(let e=i.length-1;e>=0;--e){const n=i[e];for(let e=this.dragSegments_.length-1;e>=0;--e)this.dragSegments_[e][0]===n&&this.dragSegments_.splice(e,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const i=t.getCoordinates(),n={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),n)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n],s={feature:e,geometry:t,depth:[n],index:n,segment:[r,r]};this.rBush_.insert(t.getExtent(),s)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length-1;n<r;++n){const r=i.slice(n,n+2),s={feature:e,geometry:t,index:n,segment:r};this.rBush_.insert((0,F.boundingExtent)(r),s)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,s=r.length-1;i<s;++i){const s=r.slice(i,i+2),o={feature:e,geometry:t,depth:[n],index:i,segment:s};this.rBush_.insert((0,F.boundingExtent)(s),o)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,s=r.length-1;i<s;++i){const s=r.slice(i,i+2),o={feature:e,geometry:t,depth:[n],index:i,segment:s};this.rBush_.insert((0,F.boundingExtent)(s),o)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,s=r.length;i<s;++i){const s=r[i];for(let r=0,o=s.length-1;r<o;++r){const o=s.slice(r,r+2),a={feature:e,geometry:t,depth:[i,n],index:r,segment:o};this.rBush_.insert((0,F.boundingExtent)(o),a)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),n={feature:e,geometry:t,index:0,segment:[i,i]},r={feature:e,geometry:t,index:1,segment:[i,i]},s=[n,r];n.featureSegments=s,r.featureSegments=s,this.rBush_.insert((0,F.createOrUpdateFromCoordinate)(i),n);let o=t;const a=(0,T.getUserProjection)();if(a&&this.getMap()){const e=this.getMap().getView().getProjection();o=o.clone().transform(a,e),o=(0,b.fromCircle)(o).transform(e,a)}this.rBush_.insert(o.getExtent(),r)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let t=0;t<i.length;++t){const n=i[t];(0,this.SEGMENT_WRITERS_[n.getType()])(e,n)}}createOrUpdateVertexFeature_(e,t,i){let n=this.vertexFeature_;if(n){n.getGeometry().setCoordinates(e)}else n=new(0,y.default)(new(0,v.default)(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n);return n.set("features",t),n.set("geometries",i),n}handleEvent(e){if(!e.originalEvent)return!0;let t;return this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=x.default.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=x.default.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==x.default.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],n=[];for(let r=0,s=this.dragSegments_.length;r<s;++r){const s=this.dragSegments_[r],o=s[0],a=o.feature;i.includes(a)||i.push(a);const d=o.geometry;n.includes(d)||n.push(d);const l=o.depth;let h;const u=o.segment,g=s[1];for(;t.length<d.getStride();)t.push(u[g][t.length]);switch(d.getType()){case"Point":h=t,u[0]=t,u[1]=t;break;case"MultiPoint":h=d.getCoordinates(),h[o.index]=t,u[0]=t,u[1]=t;break;case"LineString":h=d.getCoordinates(),h[o.index+g]=t,u[g]=t;break;case"MultiLineString":case"Polygon":h=d.getCoordinates(),h[l[0]][o.index+g]=t,u[g]=t;break;case"MultiPolygon":h=d.getCoordinates(),h[l[1]][l[0]][o.index+g]=t,u[g]=t;break;case"Circle":if(u[0]=t,u[1]=t,0===o.index)this.changingFeature_=!0,d.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0;const i=e.map.getView().getProjection();let n=(0,P.distance)((0,T.fromUserCoordinate)(d.getCenter(),i),(0,T.fromUserCoordinate)(t,i));const r=(0,T.getUserProjection)();if(r){const e=d.clone().transform(r,i);e.setRadius(n),n=e.transform(i,r).getRadius()}d.setRadius(n),this.changingFeature_=!1}}h&&this.setGeometryCoordinates_(d,h)}this.createOrUpdateVertexFeature_(t,i,n)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,t),this.dragSegments_.length=0,this.featuresBeingModified_=null;const i=this.vertexFeature_;if(i){const n=e.map.getView().getProjection(),r=[],s=i.getGeometry().getCoordinates(),o=(0,F.boundingExtent)([s]),a=this.rBush_.getInExtent(o),d={};a.sort(R);for(let i=0,o=a.length;i<o;++i){const o=a[i],l=o.segment;let h=(0,G.getUid)(o.geometry);const u=o.depth;if(u&&(h+="-"+u.join("-")),d[h]||(d[h]=new Array(2)),"Circle"!==o.geometry.getType()||1!==o.index)if(!(0,P.equals)(l[0],s)||d[h][0])if(!(0,P.equals)(l[1],s)||d[h][1])(0,G.getUid)(l)in this.vertexSegments_&&!d[h][0]&&!d[h][1]&&this.insertVertexCondition_(e)&&r.push(o);else{if(d[h][0]&&0===d[h][0].index){let e=o.geometry.getCoordinates();switch(o.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":e=e[u[1]];case"Polygon":if(o.index!==e[u[0]].length-2)continue}}this.dragSegments_.push([o,1]),d[h][1]=o}else this.dragSegments_.push([o,0]),d[h][0]=o;else{const e=I(t,o,n);(0,P.equals)(e,s)&&!d[h][0]&&(this.dragSegments_.push([o,0]),d[h][0]=o)}}r.length&&this.willModifyFeatures_(e,[r]);for(let e=r.length-1;e>=0;--e)this.insertVertex_(r[e],s)}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const i=this.dragSegments_[t][0],n=i.geometry;if("Circle"===n.getType()){const t=n.getCenter(),r=i.featureSegments[0],s=i.featureSegments[1];r.segment[0]=t,r.segment[1]=t,s.segment[0]=t,s.segment[1]=t,this.rBush_.update((0,F.createOrUpdateFromCoordinate)(t),r);let o=n;const a=(0,T.getUserProjection)();if(a){const t=e.map.getView().getProjection();o=o.clone().transform(a,t),o=(0,b.fromCircle)(o).transform(t,a)}this.rBush_.update(o.getExtent(),s)}else this.rBush_.update((0,F.boundingExtent)(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new A(V,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,t,i){const n=i||t.getCoordinateFromPixel(e),r=t.getView().getProjection(),s=function(e,t){return q(n,e,r)-q(n,t,r)};let o,a;if(this.hitDetection_){const i="object"==typeof this.hitDetection_?e=>e===this.hitDetection_:void 0;t.forEachFeatureAtPixel(e,((e,t,i)=>{if("Point"===(i=i||e.getGeometry()).getType()&&this.features_.getArray().includes(e)){a=i;const t=i.getFlatCoordinates().slice(0,2);o=[{feature:e,geometry:i,segment:[t,t]}]}return!0}),{layerFilter:i})}if(!o){const e=(0,T.fromUserExtent)((0,F.createOrUpdateFromCoordinate)(n,U),r),i=t.getView().getResolution()*this.pixelTolerance_,s=(0,T.toUserExtent)((0,F.buffer)(e,i,U),r);o=this.rBush_.getInExtent(s)}if(o&&o.length>0){const i=o.sort(s)[0],d=i.segment;let l=I(n,i,r);const h=t.getPixelFromCoordinate(l);let u=(0,P.distance)(e,h);if(a||u<=this.pixelTolerance_){const e={};if(e[(0,G.getUid)(d)]=!0,this.snapToPointer_||(this.delta_[0]=l[0]-n[0],this.delta_[1]=l[1]-n[1]),"Circle"===i.geometry.getType()&&1===i.index)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(l,[i.feature],[i.geometry]);else{const n=t.getPixelFromCoordinate(d[0]),r=t.getPixelFromCoordinate(d[1]),s=(0,P.squaredDistance)(h,n),a=(0,P.squaredDistance)(h,r);u=Math.sqrt(Math.min(s,a)),this.snappedToVertex_=u<=this.pixelTolerance_,this.snappedToVertex_&&(l=s>a?d[1]:d[0]),this.createOrUpdateVertexFeature_(l,[i.feature],[i.geometry]);const g={};g[(0,G.getUid)(i.geometry)]=!0;for(let t=1,i=o.length;t<i;++t){const i=o[t].segment;if(!((0,P.equals)(d[0],i[0])&&(0,P.equals)(d[1],i[1])||(0,P.equals)(d[0],i[1])&&(0,P.equals)(d[1],i[0])))break;{const n=(0,G.getUid)(o[t].geometry);n in g||(g[n]=!0,e[(0,G.getUid)(i)]=!0)}}}return void(this.vertexSegments_=e)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const i=e.segment,n=e.feature,r=e.geometry,s=e.depth,o=e.index;let a;for(;t.length<r.getStride();)t.push(0);switch(r.getType()){case"MultiLineString":case"Polygon":a=r.getCoordinates(),a[s[0]].splice(o+1,0,t);break;case"MultiPolygon":a=r.getCoordinates(),a[s[1]][s[0]].splice(o+1,0,t);break;case"LineString":a=r.getCoordinates(),a.splice(o+1,0,t);break;default:return}this.setGeometryCoordinates_(r,a);const d=this.rBush_;d.remove(e),this.updateSegmentIndices_(r,o,s,1);const l={segment:[i[0],t],feature:n,geometry:r,depth:s,index:o};d.insert((0,F.boundingExtent)(l.segment),l),this.dragSegments_.push([l,1]);const h={segment:[t,i[1]],feature:n,geometry:r,depth:s,index:o+1};d.insert((0,F.boundingExtent)(h.segment),h),this.dragSegments_.push([h,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=x.default.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new A(V,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,t={};let i,n,r,s,o,a,d,l,h,u,g,c=!1;for(o=e.length-1;o>=0;--o)r=e[o],u=r[0],g=(0,G.getUid)(u.feature),u.depth&&(g+="-"+u.depth.join("-")),g in t||(t[g]={}),0===r[1]?(t[g].right=u,t[g].index=u.index):1==r[1]&&(t[g].left=u,t[g].index=u.index+1);for(g in t){switch(h=t[g].right,d=t[g].left,a=t[g].index,l=a-1,u=void 0!==d?d:h,l<0&&(l=0),s=u.geometry,n=s.getCoordinates(),i=n,c=!1,s.getType()){case"MultiLineString":n[u.depth[0]].length>2&&(n[u.depth[0]].splice(a,1),c=!0);break;case"LineString":n.length>2&&(n.splice(a,1),c=!0);break;case"MultiPolygon":i=i[u.depth[1]];case"Polygon":i=i[u.depth[0]],i.length>4&&(a==i.length-1&&(a=0),i.splice(a,1),c=!0,0===a&&(i.pop(),i.push(i[0]),l=i.length-1))}if(c){this.setGeometryCoordinates_(s,n);const t=[];if(void 0!==d&&(this.rBush_.remove(d),t.push(d.segment[0])),void 0!==h&&(this.rBush_.remove(h),t.push(h.segment[1])),void 0!==d&&void 0!==h){const e={depth:u.depth,feature:u.feature,geometry:u.geometry,index:l,segment:t};this.rBush_.insert((0,F.boundingExtent)(e.segment),e)}this.updateSegmentIndices_(s,a,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return c}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,n){this.rBush_.forEachInExtent(e.getExtent(),(function(r){r.geometry===e&&(void 0===i||void 0===r.depth||(0,M.equals)(r.depth,i))&&r.index>t&&(r.index+=n)}))}}function R(e,t){return e.index-t.index}function q(e,t,i){const n=t.geometry;if("Circle"===n.getType()){let r=n;if(1===t.index){const t=(0,T.getUserProjection)();t&&(r=r.clone().transform(t,i));const n=(0,P.squaredDistance)(r.getCenter(),(0,T.fromUserCoordinate)(e,i)),s=Math.sqrt(n)-r.getRadius();return s*s}}const r=(0,T.fromUserCoordinate)(e,i);return B[0]=(0,T.fromUserCoordinate)(t.segment[0],i),B[1]=(0,T.fromUserCoordinate)(t.segment[1],i),(0,P.squaredDistanceToSegment)(r,B)}function I(e,t,i){const n=t.geometry;if("Circle"===n.getType()&&1===t.index){let t=n;const r=(0,T.getUserProjection)();return r&&(t=t.clone().transform(r,i)),(0,T.toUserCoordinate)(t.getClosestPoint((0,T.fromUserCoordinate)(e,i)),i)}const r=(0,T.fromUserCoordinate)(e,i);return B[0]=(0,T.fromUserCoordinate)(t.segment[0],i),B[1]=(0,T.fromUserCoordinate)(t.segment[1],i),(0,T.toUserCoordinate)((0,P.closestOnSegment)(r,B),i)}function N(){const e=(0,u.createEditingStyle)();return function(t,i){return e.Point}}var O=D,k=r("6yJ0x"),j=r("1B70O");(0,r("jZUWm").default)(e('<div> <h2> Day 14: hexagons </h2> <p> Use <a href="http://viglino.github.io/ol-ext/doc/doc-pages/ol.style.FlowLine.html" target="_new"> ol-ext Hexbin source </a> to aggregate data on hexagons. </p> </div>')),j.default.getView().setZoom(13),j.default.getView().setCenter([259982,6250835]);const H=new(0,a.default)({layer:"GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2"});j.default.addLayer(H);const W=new(0,s.default)({source:new(0,o.default)({url:"./paris-photo.geojson",format:new(0,d.default),attributions:["<a href='https://twitter.com/search?q=paris%20autrefois%20%28from%3ASamuelMartin75%29&src=typed_query&f=live'>@SamuelMartin</a>"]})}),K=new(0,l.default)({source:W.getSource(),size:500}),z=new(0,h.default)({title:"Bin",className:"bin",source:K,style:e=>{const t=[0,170,255,e.get("features").length/10+.11];return new(0,u.default)({fill:new(0,g.default)({color:t})})}});z.addFilter(new(0,c.default)({blend:"multiply"})),j.default.addLayer(z),j.default.addLayer(W);const X=new O({source:K.getSource()});j.default.addInteraction(X),j.default.addInteraction(new(0,k.default)({layers:[W],cursor:"move"}));